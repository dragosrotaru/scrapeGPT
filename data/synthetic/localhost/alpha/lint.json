[
  {
    "filePath": "<text>",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "output": "\nconst puppeteer = require(\"puppeteer\");\n    \n(async () => {\n    try {\n        const url = \"http://localhost\";\n        const params = {\n            \"type\": \"house\",\n            \"city\": \"New York\",\n            \"state\": \"NY\",\n            \"zip\": \"10001\",\n            \"bedrooms\": \"3\",\n            \"maxPrice\": \"500000\",\n            \"minPrice\": \"200000\"\n        };\n        const browser = await puppeteer.launch({ headless: false });\n        const page = await browser.newPage();\n        page.setViewport({ width: 1400, height: 1000 });\n        page.setUserAgent(\"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome\");\n        await page.goto(url, { waitUntil: \"networkidle2\" });\n\n        const events = {\n            pageChanges: [],\n            formSubmissions: [],\n            xhrRequests: [],\n        };\n\n        await page.setRequestInterception(true);\n\n        page.on(\"framenavigated\", (frame) => {\n            events.pageChanges.push({\n                url: frame.url(),\n                status: frame._navigationResponse\n                    ? frame._navigationResponse.status()\n                    : null,\n            });\n        });\n\n        page.on(\"request\", (interceptedRequest) => {\n            if (\n                interceptedRequest._method === \"POST\" &&\n                    interceptedRequest._postData\n            ) {\n                events.formSubmissions.push({\n                    url: interceptedRequest.url(),\n                    postData: interceptedRequest._postData,\n                    status: interceptedRequest._response\n                        ? interceptedRequest._response.status()\n                        : null,\n                });\n            }\n            interceptedRequest.continue();\n        });\n\n        page.on(\"response\", (response) => {\n            const request = response.request();\n            if (request.resourceType() === \"xhr\") {\n                events.xhrRequests.push({\n                    url: request.url(),\n                    status: response.status(),\n                });\n            }\n        });\n\n        try {\n                \n            async function fillFormAndSubmit(inputs) {\n                if(inputs.type) {\n                    await page.select('#type', inputs.type);\n                }\n                if(inputs.city) {\n                    await page.type('#city', inputs.city);\n                }\n                if(inputs.state) {\n                    await page.type('#state', inputs.state);\n                }\n                if(inputs.zip) {\n                    await page.type('#zip', inputs.zip);\n                }\n                if(inputs.bedrooms) {\n                    await page.type('#bedrooms', inputs.bedrooms);\n                }\n                if(inputs.maxPrice) {\n                    await page.type('#maxPrice', inputs.maxPrice);\n                }\n                if(inputs.minPrice) {\n                    await page.type('#minPrice', inputs.minPrice);\n                }\n                await page.click('input[type=\"submit\"]');\n            }\n\n            await fillFormAndSubmit(params);\n        } catch (error) {\n            return { events, innerError: error.message };\n        }\n    \n        await Promise.race([\n            page.waitForNetworkIdle({ waitUntil: \"networkidle0\" }),\n            page.waitForTimeout(5000)\n        ]);\n        const newUrl = page.url();\n    \n        browser.close();\n    \n        return { events, url: newUrl };\n    } catch (error) {\n        return { outerError: error.message };\n    }\n})();\n",
    "usedDeprecatedRules": []
  }
]